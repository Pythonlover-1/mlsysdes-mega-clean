# Diagram-to-CSV Service — описание системы

## Основные компоненты

| Компонент | Технология | Роль |
|-----------|-----------|------|
| **UI** | React + Vite + Tailwind | Загрузка изображения, отображение результата (таблица, raw CSV, превью), история конвертаций |
| **API** | FastAPI (Python) | Единственный эндпоинт `POST /api/convert` — принимает изображение, возвращает CSV |
| **ML-модель** | GPT-4o через OpenRouter API | Мультимодальная модель — принимает изображение диаграммы, извлекает структуру как CSV |
| **Препроцессинг** | `llm.py` | Кодирование изображения в base64, формирование промпта |
| **Постпроцессинг** | Фронтенд (CsvTable) | Парсинг CSV-строки в HTML-таблицу |
| **Хранилище** | localStorage (браузер) | История конвертаций (до 50 записей) — CSV + превью изображения |

## Поток данных

```
Пользователь                UI (React)              API (FastAPI)           OpenRouter (GPT-4o)
    │                          │                          │                        │
    │──── drag & drop ────────>│                          │                        │
    │     изображение          │                          │                        │
    │     диаграммы            │                          │                        │
    │                          │── POST /api/convert ────>│                        │
    │                          │   multipart/form-data    │                        │
    │                          │                          │── base64 image ───────>│
    │                          │                          │   + prompt             │
    │                          │                          │                        │
    │                          │                          │<── CSV text ───────────│
    │                          │<── { csv, filename } ────│                        │
    │                          │                          │                        │
    │<── таблица + raw CSV ────│                          │                        │
    │    + кнопка скачивания   │                          │                        │
    │    + сохранение в        │                          │                        │
    │      localStorage        │                          │                        │
```

**Вход:** изображение диаграммы (блок-схема, flowchart, граф, ER-диаграмма, и т.п.).

**Обработка:**
1. Фронтенд читает файл, отправляет как `multipart/form-data` на `/api/convert`
2. Бэкенд кодирует изображение в base64, отправляет в OpenRouter API с промптом «разбери структуру диаграммы и представь в табличном виде»
3. LLM анализирует визуальную структуру диаграммы (узлы, связи, подписи) и формирует CSV

**Выход:** JSON `{ csv: "...", filename: "..." }` — фронтенд рендерит интерактивную таблицу, raw CSV и кнопку скачивания.

## Где используется ML/LLM

Единственная точка — `backend/app/services/llm.py`. Мультимодальная модель GPT-4o (или другая, заданная через `OPENROUTER_MODEL`) получает изображение диаграммы и текстовый промпт. Задача модели — понять визуальную структуру (элементы, связи, иерархию) и перевести её в табличное текстовое представление (CSV). Модель не запускается локально — используется внешний API (OpenRouter).

## Развёртывание

- **Docker Compose** — два контейнера:
  - `backend` — Python/uvicorn на порту 8000
  - `frontend` — multi-stage build (Node → nginx) на порту 3000, nginx проксирует `/api` на backend
- **CPU only** — модель работает удалённо через API, GPU не нужен
- Запуск: `OPENROUTER_API_KEY=... docker compose up --build`

---

## Направления развития

Текущий подход (одна мультимодальная LLM разбирает диаграмму целиком) — baseline. Планируем проверить три альтернативных направления:

### 1. Легковесная LLM + файнтюнинг

Заменить тяжёлую general-purpose модель на компактную, заточенную под разбор диаграмм.

- Собрать датасет: пары (изображение диаграммы → табличное представление). Ground truth генерировать сильной моделью (GPT-4o) + ручная проверка.
- Файнтюнить компактную vision-language модель (Qwen-VL, PaliGemma) на этом датасете.
- Ожидаемый результат: дешевле, быстрее, возможен локальный запуск на GPU.

### 2. CV-пайплайн: детекция + сегментация + OCR

Отказаться от LLM в пользу специализированных CV-моделей.

- Детекция элементов диаграммы: блоки, стрелки, подписи (YOLO / специализированный детектор).
- Сегментация: выделить отдельные узлы и связи между ними.
- OCR для извлечения текста из каждого элемента.
- Правила сборки: по координатам и связям восстановить структуру → CSV.
- Ожидаемый результат: предсказуемый, управляемый пайплайн без галлюцинаций, работает офлайн.

### 3. Гибридный подход: CV + LLM

CV-модели для структурной работы (где элементы, какие связи), LLM — для понимания смысла и формирования итоговой таблицы.

- **Сегментация → LLM**: CV выделяет отдельные блоки диаграммы, LLM получает уже нарезанные фрагменты — меньше шума, точнее результат.
- **OCR + LLM**: OCR извлекает текст из элементов диаграммы, LLM структурирует текст + позиционную информацию в таблицу (работает с текстом, а не с изображением — дешевле).
- **Перевод RU → EN → RU**: исходные диаграммы на русском языке, а мультимодальные модели точнее работают с английским. Идея — OCR/LLM извлекает русский текст, переводит на английский, выполняет структурный разбор на английском, затем переводит результат обратно на русский. Проверить, даёт ли это прирост точности по сравнению с прямой работой на русском.

### Сравнение подходов

| Критерий | Baseline (LLM) | Файнтюнинг | CV-пайплайн | Гибрид |
|----------|----------------|------------|-------------|--------|
| Точность на простых диаграммах | Высокая | Высокая | Средняя | Высокая |
| Точность на сложных диаграммах | Средняя | ? | Низкая | Средняя-Высокая |
| Стоимость инференса | Высокая | Низкая | Низкая | Средняя |
| Локальный запуск | Нет | Да (GPU) | Да (CPU/GPU) | Частично |
| Предсказуемость | Низкая | Средняя | Высокая | Средняя |
| Галлюцинации | Возможны | Возможны | Нет | Частично |
